syntax = "proto3";

package LLVM.TDG;

enum StreamStepPattern {
  UNKNOWN = 0;
  UNCONDITIONAL = 1;
  CONDITIONAL = 2;
  NEVER = 3;
}

enum StreamValuePattern {
  RANDOM = 0;
  CONSTANT = 1;
  LINEAR = 2;
  QUARDRIC = 3;
  INDIRECT = 4;
  POINTER_CHASE = 5;
  PREV_LOAD = 6;
}

message StreamParam {
  int64 value = 1;
  bool is_static = 2;
}

// Pattern describe the induction variable.
message IVPattern {
  StreamValuePattern val_pattern = 1;
  repeated StreamParam params = 2;
}

// Describe the static coalesce information.
message StaticCoalesceInfo {
  uint64 base_stream = 1;
  int32 offset = 2;
}

message StreamId {
  string name = 1;
  uint64 id = 2;
}

message PredicatedStreamId {
  StreamId id = 1;
  bool pred_true = 2;
}

message ExecFuncInfo {
  string name = 1;
  message FuncArg {
    bool is_stream = 1;
    uint64 stream_id = 2;
  }
  repeated FuncArg args = 2;
}

message StaticStreamInfo {
  bool is_candidate = 1;
  bool is_qualified = 2;
  bool is_chosen = 3;
  StreamStepPattern stp_pattern = 4;
  StreamValuePattern val_pattern = 5;
  StaticNotStreamReason not_stream_reason = 6;
  uint32 loop_possible_path = 7;
  uint32 config_loop_possible_path = 8;
  IVPattern iv_pattern = 9;
  bool float_manual = 10;
  bool has_update = 11; // The load stream has aliased store.
  bool has_const_update = 12; // This load stream is updated by a constant value.
  bool has_upgraded_to_update = 13; // This load stream has been upgraded to update.
  StreamParam const_update_param = 14;
  bool is_cond_access = 15; // Whether this is conditional access.
  bool is_trip_count_fixed = 16; // Whether the trip count is know at configure time.
  repeated PredicatedStreamId predicated_streams = 18; // Predicated streams.
  repeated PredicatedStreamId merged_predicated_streams = 19; // Merged predicated streams.
  bool is_merged_predicated_stream = 20; // This predicated stream has been merged.
  ExecFuncInfo pred_func_info = 21;

  enum StaticNotStreamReason {
    UNKNOWN = 0;
    // Not Candidate Reason.
    BASE_STREAM_INNER_MOST_LOOP_NOT_CONTAIN_MINE = 1;
    MULTI_PHIMNODE_FOR_COMPUTEMNODE = 2;
    MULTI_NON_EMPTY_COMPUTE_PATH = 3;
    NOT_SCEVABLE_COMPUTEMNODE = 4;
    RANDOM_PATTERN = 5;
    MULTI_STEP_ROOT = 6;
    NO_STEP_ROOT = 7;
    VARIANT_BACKEDGE_TAKEN = 8;
    IS_UPDATE_STORE = 9;
    // Not Qualified Reason.
    BASE_STREAM_NOT_QUALIFIED = 10;
    NO_STATIC_MAPPING = 11;
  }
}

message DynamicStreamInfo {
  bool is_candidate = 1;
  bool is_qualified = 2;
  bool is_chosen = 3;
  bool is_aliased = 4;
  uint64 total_iters = 5;
  uint64 total_accesses = 6;
  uint64 total_configures = 7;
}

message StreamInfo {
  string name = 1;
  uint64 id = 2;
  string type = 3;
  uint32 loop_level = 4;
  uint32 config_loop_level = 5;
  int32 element_size = 6;
  string pattern_path = 7;
  string history_path = 8;
  StaticCoalesceInfo coalesce_info = 9;

  DynamicStreamInfo dynamic_info = 10;
  int32 region_stream_id = 11;
  ExecFuncInfo addr_func_info = 12;

  repeated StreamId base_streams = 16;
  repeated StreamId back_base_streams = 17;
  repeated StreamId chosen_base_streams = 18;
  repeated StreamId chosen_back_base_streams = 19;

  // Mark if this is stream is statically qualifed without any dynamic
  // information.
  StaticStreamInfo static_info = 24;

}

message StreamRegion {
  string region = 1;
  // How many streams may coexist with this region (including
  // parent/sub-region).
  int32 total_alive_streams = 2;
  int32 total_alive_coalesced_streams = 3;
  repeated StreamInfo streams = 8;
  repeated uint64 coalesced_stream_ids = 9;
}

// All the configured stream region in one place.
message AllStreamRegions {
  string binary = 1;
  repeated string relative_paths = 2;
};

message StreamPattern {
  // Describe the pattern of the a dynamic direct stream.
  string val_pattern = 1;
  string acc_pattern = 2;
  uint64 iters = 3;
  uint64 accesses = 4;
  uint64 updates = 5;
  uint64 base = 6;
  int64 stride_i = 7;
  uint64 ni = 8;
  int64 stride_j = 9;
  repeated HistoryEntry history = 10;

  message HistoryEntry {
    bool valid = 1;
    uint64 value = 2;
  }
}

message StreamHistory {
  // Describe the accessed entries of the a dynamic stream.
  message HistoryEntry {
    bool valid = 1;
    uint64 addr = 2;
    bool used = 3;
  }
  uint64 id = 1;
  repeated HistoryEntry history = 2;
  uint64 num_cache_lines = 3;
  uint64 num_accesses = 4;
}